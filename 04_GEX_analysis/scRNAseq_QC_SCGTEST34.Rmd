---
title: "scRNAseq QC parameters"
author: "Laura Jim√©nez Gracia"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
                      fig.align = "center")
```

# Introduction
Following with the results obtained in the previous notebook, we will now perform other pre-processing steps, such as data normalization, feature selection, scaling, dimensionality reduction, and data visualization prior to batch-effect correction (data integration). To do so, we will follow the current best practices for scRNA-seq QC described in [Luecken al. Mol Syst Biol (2018)](https://doi.org/10.15252/msb.20188746) and adapt some workflows from [Satija Lab](https://satijalab.org/seurat/vignettes.html).

## Objective
In this Rmarkdown document, we are going to perform the previous pre-processing steps.

# Pre-processing
## Libraries
```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(Seurat)
library(gt)
```

## Parameters
Here we will define and load objects and functions that will be used throughout the document.
```{r}
# Paths
path_project_metadata <- here::here("01_cellranger_mapping/data/FIXnCUT_metadata.csv")

# Functions
source(here::here("bin/utils.R"))

# Parameters
confounder_variables <- c("library_name", "sample_protocol", "fixation_time")
confounder_names <- c("Library", "Sample Protocol", "Fixation time")

metadata_variables_confounder <- c("nCount_RNA", "nFeature_RNA", "gem_id", 
                                   "pct_mt", "pct_rb", "Phase",
                                   "library_name", "sample_protocol", "fixation_time")

set.seed(1234) # for reproducibility 
```

## Load metadata
The data used in this Rmarkdown document comes from **SCGTEST_34** dataset.
```{r}
# Load all metadata information
metadata <- read.csv(path_project_metadata)

# Merging metadata tables
metadata <- metadata %>% 
  filter(subproject == "SCGTEST_34" & tissue == "PBMC")

print("Libraries/Samples metadata")
DT::datatable(metadata, options = list(scrollX = TRUE))
```


# UNFILTERED
```{r}
# Load Seurat object
seurat_obj <- readRDS(here::here("02_QC/results/R_objects/scgtest34_h_PBMC_healthy_merged.rds"))
seurat_obj
```

Here, we show an overview of the scRNA-seq data obtained after the quality control.
```{r}
table_qc_gex(seurat_obj@meta.data, subtitle = "After cell QC filtering out")
```

## # UMIs /  cell

```{r fig.height=6, fig.width=8}
ggplot(seurat_obj@meta.data, 
       aes(x = sample_protocol, y = nCount_RNA, fill = sample_protocol)) +
  geom_boxplot(outlier.shape = NA) +
  theme_classic() +
    ggpubr::stat_compare_means(ref.group = "Fresh", method = "wilcox.test",
                                 label = "p.format", label.y.npc = 0.95) + # p.format)
  scale_y_log10() +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text = element_text(size=16),
        strip.text = element_text(size=18),
        legend.title = element_text(size=16),
        legend.text = element_text(size=15),
        legend.position = "none"
        )
```


## # Genes /  cell

```{r fig.height=6, fig.width=8}
ggplot(seurat_obj@meta.data, 
       aes(x = sample_protocol, y = nFeature_RNA, fill = sample_protocol)) +
  geom_boxplot(outlier.shape = NA) +
  theme_classic() +
    ggpubr::stat_compare_means(ref.group = "Fresh", method = "wilcox.test",
                                 label = "p.format", label.y.npc = 0.95) + # p.format)
  scale_y_log10() +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text = element_text(size=16),
        strip.text = element_text(size=18),
        legend.title = element_text(size=16),
        legend.text = element_text(size=15),
        legend.position = "none"
        )
```



## % MT expression

```{r fig.height=6, fig.width=8}
ggplot(seurat_obj@meta.data, 
       aes(x = sample_protocol, y = pct_mt, fill = sample_protocol)) +
  geom_boxplot(outlier.shape = NA) +
  theme_classic() +
    ggpubr::stat_compare_means(ref.group = "Fresh", method = "wilcox.test",
                                 label = "p.format", label.y.npc = 0.95) + # p.format)
  ylim(0, 20) +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text = element_text(size=16),
        strip.text = element_text(size=18),
        legend.title = element_text(size=16),
        legend.text = element_text(size=15),
        legend.position = "none"
        )
```

## # Genes / # cells
```{r}
size_list <- seq(1, 100, by=2)

detectedgenes_df <- data.frame(matrix(
  ncol =  length(levels(seurat_obj$sample_protocol)),
  nrow = length(size_list)), 
  row.names = as.character(size_list))
names(detectedgenes_df) <- levels(seurat_obj$sample_protocol)



Idents(seurat_obj) <- "sample_protocol"
for (size in size_list) {
  #print(size)
  for (protocol in levels(seurat_obj$sample_protocol)) {
  #print(protocol)
    seurat_obj_sub <- seurat_obj[, seurat_obj$sample_protocol == protocol]
    detectedgenes_list <- list()

    for (var in 1:50) {
      seurat_obj_sub_n <- subset(x = seurat_obj_sub, downsample = size)
      #print(table(seurat_obj_sub$sample_protocol))
  
      m <- rowSums(seurat_obj_sub_n@assays$RNA@counts != 0)
      detected_genes <- length(m[m > 0])
      #print(detected_genes)
      detectedgenes_list[var] <- detected_genes
    }
  
    mean_detectedgenes <- mean(unlist(detectedgenes_list))
    #print(mean_detectedgenes)
    detectedgenes_df[as.character(size), protocol] <- mean_detectedgenes  
    
  }
}

detectedgenes_df
detectedgenes_df$num_cells <- as.integer(rownames(detectedgenes_df))

detectedgenes <- detectedgenes_df %>% 
  gather(key = "sample_protocol", value = "detected_genes", `Fresh`:`Fix&Cut_24h`)
```


```{r fig.width=10, fig.height=6}
detectedgenes %>% 
  ggplot(aes(x = num_cells, y = detected_genes, color = sample_protocol)) +
  geom_point() +
  geom_line() +
  theme_bw() +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2")
```


## # Genes / # Seq reads
```{r}
cell_info_df <- data.frame(matrix(ncol = 5, nrow = 0))
colnames(cell_info_df) <- c("cell", "reads", "umi", "gene", "protocol")


for (protocol in metadata$sample_protocol) {
  #print(protocol)
  gem_id <- unique(metadata$gem_id[metadata$sample_protocol == protocol])

  path_general <- here::here("01_cellranger_mapping/subprojects/SCGTEST_34/jobs")
  mol.info.path <- paste(path_general, gem_id, gem_id, "outs/per_sample_outs", gem_id, "count/sample_molecule_info.h5", sep = "/")
  mol.info.file <- DropletUtils::read10xMolInfo(mol.info.path)
  
    # Get the number of reads / cell [Category, x]
  reads_cell_df <- aggregate(mol.info.file$data$reads, 
                             by= list(cell=(mol.info.file$data$cell)),
                             FUN=sum)
  names(reads_cell_df)[names(reads_cell_df) == "x"] <- "reads"
  
  # Get the number of umi / cell [Category, x]
  umi_cell_df <- aggregate(data = mol.info.file$data,
            umi ~ cell, 
            FUN=function(umi) length(unique(umi))
            )
  
  # Get the number of genes / cell [Category, x]
  gene_cell_df <- aggregate(data = mol.info.file$data,
            gene ~ cell, 
            FUN=function(gene) length(unique(gene))
            )
  
  df <- full_join(reads_cell_df, umi_cell_df, by = "cell")
  df <- full_join(df, gene_cell_df, by = "cell")
  df$protocol <- protocol

  # Information
  #sum(df$reads)
  #sum(df$umi)
  #No possible for genes, as they might be repeated across cells!
  
  cell_info_df <- rbind(cell_info_df, df)
}

# Computing slope
for (protocol in metadata$sample_protocol) {
  fit1 <- lm(formula =  gene ~ reads, data = cell_info_df[cell_info_df$protocol == protocol, ])
  #summary(fit1)
  slope <- round(coef(fit1)[2], digits = 5)
  print(slope)

  index <- rownames(cell_info_df[cell_info_df$protocol == protocol, ][which.max(cell_info_df[cell_info_df$protocol == protocol, ]$reads), ])
  cell_info_df[index, "slope"] <- slope
}
cell_info_df
```


```{r fig.width=12, fig.height=8}
cell_info_df %>%
  ggplot(aes(x = reads, y = gene, color = protocol, label = slope)) +
  geom_point(alpha=0.25) +
  scale_color_brewer(palette = "Set2") +
  stat_smooth(method='lm', se=FALSE) + # fitted linear regression model
  scale_x_continuous(labels = scales::comma) +
  labs(x = "Sequencing depth (# Reads)",
     y = "Library complexity (# Genes)",
     color = "Protocol") +
  theme_bw() +
  geom_text(size=5)

cell_info_df %>%
  ggplot(aes(x = reads, y = gene, color = protocol, label = slope)) +
  geom_point(alpha=0.25) +
  scale_color_brewer(palette = "Set2") +
  stat_smooth(method='lm', se=FALSE) + # fitted linear regression model
  scale_x_log10(labels = scales::comma) +
  labs(x = "Sequencing depth (Log10(# Reads))",
     y = "Library complexity (# Genes)",
     color = "Protocol") +
  theme_bw() +
  geom_text(size=5)
```



## # Genes / # UMIs (downsampling reads)
https://github.com/MarioniLab/DropletUtils/blob/master/vignettes/DropletUtils.Rmd

Downsampling on the reads

Given multiple batches of very different sequencing depths, it can be beneficial to downsample the deepest batches to match the coverage of the shallowest batches. This avoids differences in technical noise that can drive clustering by batch.

The `r Biocpkg("scuttle")` package provides some utilities to downsample count matrices, but technically speaking, downsampling on the reads is more appropriate as it recapitulates the effect of differences in sequencing depth per cell.

This can be achieved by applying the `downsampleReads` function to the molecule information file containing the read counts:

downsample the **reads** to 50% of the original coverage across the experiment.
the function returns a matrix of **UMI counts** --> total count may not actually decrease (if the libraries are sequenced to saturation)

Users should use `downsampleMatrix()` instead if they want to guarantee similar total counts after downsampling.


```{r}
prop_list <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)

seqreads_genes_df <- data.frame(matrix(ncol = 4, nrow = 0))
colnames(seqreads_genes_df) <- c("sequenced_reads", "sequenced_UMIs", "detected_genes", "sample_protocol")

for (protocol in metadata$sample_protocol) {
  #print(protocol)
  gem_id <- unique(metadata$gem_id[metadata$sample_protocol == protocol])

  path_general <- here::here("01_cellranger_mapping/subprojects/SCGTEST_34/jobs")
  mol.info.path <- paste(path_general, gem_id, gem_id, "outs/multi/count/raw_molecule_info.h5", sep = "/")
  mol.info.file <- DropletUtils::read10xMolInfo(mol.info.path)
  
  all_reads <- sum(mol.info.file$data$reads)
  #print(all_reads)

  for (proportion in prop_list) {
    #print(proportion)
    
    sequenced_reads <- all_reads*proportion
    #print(sequenced_reads)
    
    with.sampling <- DropletUtils::downsampleReads(mol.info.path, prop=proportion)

    sequenced_UMIs <- sum(with.sampling)
    #print(sequenced_UMIs)
    
    m <- rowSums(with.sampling)
    detected_genes <- length(m[m > 0])
    #print(detected_genes)

    seqreads_genes_df[nrow(seqreads_genes_df)+1, ] <- c(sequenced_reads, sequenced_UMIs, detected_genes, protocol)
  }
}

seqreads_genes_df$sequenced_reads <- as.integer(seqreads_genes_df$sequenced_reads)
seqreads_genes_df$sequenced_reads_M <- seqreads_genes_df$sequenced_reads/1000000
seqreads_genes_df$sequenced_UMIs <- as.integer(seqreads_genes_df$sequenced_UMIs)
seqreads_genes_df$detected_genes <- as.integer(seqreads_genes_df$detected_genes)


for (protocol in metadata$sample_protocol) {
  fit1 <- lm(formula =  detected_genes ~ sequenced_reads, data = seqreads_genes_df[seqreads_genes_df$sample_protocol == protocol, ])
  #summary(fit1)
  slope <- round(coef(fit1)[2], digits = 6)
  print(slope)

  index <- rownames(seqreads_genes_df[seqreads_genes_df$sample_protocol == protocol, ][which.max(seqreads_genes_df[seqreads_genes_df$sample_protocol == protocol, ]$sequenced_reads), ])
  seqreads_genes_df[index, "slope"] <- slope
}
seqreads_genes_df
```


```{r fig.width=10, fig.height=6}
seqreads_genes_df %>%
  ggplot(aes(x = sequenced_reads_M, y = detected_genes, color = sample_protocol, label = slope)) +
  geom_point(alpha=0.5) +
  geom_smooth(se=FALSE) +
  #xlim(0, 150) +
  #scale_x_continuous(labels = scales::comma) +
  #scale_x_log10(labels = scales::comma) +
  #stat_smooth(method='lm', se=FALSE) + # fitted linear regression model
  theme_bw() +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  #geom_text() + 
  labs(x = "Sequencing depth (Log10(# Million Reads))",
     y = "Library complexity (# Genes)",
     color = "Protocol")
```



# FILTERED & ANNOTATED
```{r}
# Load Seurat object
seurat_obj <- readRDS(here::here("03_clustering_annotation/results/R_objects/scgtest34_h_PBMC_healthy_cells1_clustering_annotation.rds"))
seurat_obj

seurat_obj <- subset(seurat_obj, subset = celltypes_1 != "Low quality cells")

# Reorder factor
seurat_obj$sample_protocol <- factor(x = seurat_obj$sample_protocol,
                                    levels = c("Fresh", "Fix&Cut_24h"))
```


Here, we show an overview of the scRNA-seq data obtained after the quality control.
```{r}
table_qc_gex(seurat_obj@meta.data, subtitle = "After cell QC filtering out")
```




## # UMIs /  cell

```{r fig.height=6, fig.width=8}
ggplot(seurat_obj@meta.data, 
       aes(x = sample_protocol, y = nCount_RNA, fill = sample_protocol)) +
  geom_boxplot(outlier.shape = NA) +
  theme_classic() +
    ggpubr::stat_compare_means(ref.group = "Fresh", method = "wilcox.test",
                                 label = "p.format", label.y.npc = 0.95) + # p.format)
  scale_y_log10() +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text = element_text(size=16),
        strip.text = element_text(size=18),
        legend.title = element_text(size=16),
        legend.text = element_text(size=15),
        legend.position = "none"
        )
```



```{r fig.height=12, fig.width=20}
ggplot(seurat_obj@meta.data, 
       aes(x = sample_protocol, y = nCount_RNA, fill = sample_protocol)) +
  geom_boxplot(outlier.shape = NA) +
  theme_classic() +
    ggpubr::stat_compare_means(ref.group = "Fresh", method = "wilcox.test",
                                 label = "p.signif", label.y.npc = 0.95) + # p.format)
  scale_y_log10() +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  facet_wrap(~celltypes_1, scales = "fixed", ncol = 5) + 
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text = element_text(size=16),
        strip.text = element_text(size=18),
        legend.position = c(0.8, -0.1),
        legend.title = element_text(size=16),
        legend.text = element_text(size=15)
        )
```

## # Genes /  cell

```{r fig.height=6, fig.width=8}
ggplot(seurat_obj@meta.data, 
       aes(x = sample_protocol, y = nFeature_RNA, fill = sample_protocol)) +
  geom_boxplot(outlier.shape = NA) +
  theme_classic() +
    ggpubr::stat_compare_means(ref.group = "Fresh", method = "wilcox.test",
                                 label = "p.format", label.y.npc = 0.95) + # p.format)
  scale_y_log10() +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text = element_text(size=16),
        strip.text = element_text(size=18),
        legend.title = element_text(size=16),
        legend.text = element_text(size=15),
        legend.position = "none"
        )
```



```{r fig.height=12, fig.width=20}
ggplot(seurat_obj@meta.data, 
       aes(x = sample_protocol, y = nFeature_RNA, fill = sample_protocol)) +
  geom_boxplot(outlier.shape = NA) +
  theme_classic() +
    ggpubr::stat_compare_means(ref.group = "Fresh", method = "wilcox.test",
                                 label = "p.signif", label.y.npc = 0.95) + # p.format)
  scale_y_log10() +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  facet_wrap(~celltypes_1, scales = "fixed", ncol = 5) + 
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text = element_text(size=16),
        strip.text = element_text(size=18),
        legend.position = c(0.8, -0.1),
        legend.title = element_text(size=16),
        legend.text = element_text(size=15)
        )
```


## % MT expression

```{r fig.height=6, fig.width=8}
ggplot(seurat_obj@meta.data, 
       aes(x = sample_protocol, y = pct_mt, fill = sample_protocol)) +
  geom_boxplot(outlier.shape = NA) +
  theme_classic() +
    ggpubr::stat_compare_means(ref.group = "Fresh", method = "wilcox.test",
                                 label = "p.format", label.y.npc = 0.95) + # p.format)
  ylim(0, 15) +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text = element_text(size=16),
        strip.text = element_text(size=18),
        legend.title = element_text(size=16),
        legend.text = element_text(size=15),
        legend.position = "none"
        )
```



```{r fig.height=12, fig.width=20}
ggplot(seurat_obj@meta.data, 
       aes(x = sample_protocol, y = pct_mt, fill = sample_protocol)) +
  geom_boxplot(outlier.shape = NA) +
  theme_classic() +
    ggpubr::stat_compare_means(ref.group = "Fresh", method = "wilcox.test",
                                 label = "p.signif", label.y.npc = 0.95) + # p.format)
  ylim(0, 20) +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  facet_wrap(~celltypes_1, scales = "fixed", ncol = 5) + 
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text = element_text(size=16),
        strip.text = element_text(size=18),
        legend.position = c(0.8, -0.1),
        legend.title = element_text(size=16),
        legend.text = element_text(size=15)
        )
```


# Session Info
```{r}
sessionInfo()
```