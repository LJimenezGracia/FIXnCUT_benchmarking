---
title: "scRNAseq batch-effects"
author: "Laura Jim√©nez Gracia"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
                      fig.align = "center")
```

# Introduction

## Objective
In this Rmarkdown document, we are going to explore and compare group effects in single-cell RNA-seq data.

# Pre-processing
## Libraries
```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(Seurat)
library(gt)
library(CellMixS)
library(SingleCellExperiment)
library(variancePartition)
```

## Parameters
Here we will define and load objects and functions that will be used throughout the document.
```{r}
# Paths
path_project_metadata <- here::here("01_cellranger_mapping/data/FIXnCUT_metadata.csv")

# Functions
source(here::here("bin/utils.R"))

# Parameters
confounder_variables <- c("library_name", "sample_protocol", "fixation_time")
confounder_names <- c("Library", "Sample Protocol", "Fixation time")

metadata_variables_confounder <- c("nCount_RNA", "nFeature_RNA", "gem_id", 
                                   "pct_mt", "pct_rb", "Phase",
                                   "library_name", "sample_protocol", "fixation_time")

set.seed(1234) # for reproducibility 
```

## Load metadata
The data used in this Rmarkdown document comes from **SCGTEST_33** dataset.
```{r}
# Load all metadata information
metadata <- read.csv(path_project_metadata)

# Merging metadata tables
metadata <- metadata %>% 
  filter(subproject == "SCGTEST_33" & tissue == "Lung")

print("Libraries/Samples metadata")
DT::datatable(metadata, options = list(scrollX = TRUE))
```

## Load Seurat object
```{r}
# Load FILTERED & NOT integrated
seurat_obj <- readRDS(here::here("02_QC/results/R_objects/scgtest33_m_LUNG_healthy_lognorm_processed.rds"))

# Reorder factor
seurat_obj$sample_protocol <- factor(x = seurat_obj$sample_protocol,
                                    levels = c("Fresh", "Fix&Cut_24h", "Fix&Cut_7d", "Cryopreservation", "Fix&Cut+Cryopreservation"))
```

```{r}
# Extract raw counts and metadata to create SingleCellExperiment object
counts <- seurat_obj@assays$RNA@counts 
data <- seurat_obj@assays$RNA@data
metadata <- seurat_obj@meta.data

# Create single cell experiment object
sce <- SingleCellExperiment(assays = list(counts = counts,
                                          data = data), 
                           colData = metadata)
```

```{r}
# Load FILTERED & Integrated & Annotated
seurat_obj_final <- readRDS(here::here("03_clustering_annotation/results/R_objects/scgtest33_m_LUNG_healthy_cells1_clustering_annotation.rds"))

# Reorder factor
seurat_obj_final$sample_protocol <- factor(x = seurat_obj_final$sample_protocol,
                                    levels = c("Fresh", "Fix&Cut_24h", "Fix&Cut_7d", "Cryopreservation", "Fix&Cut+Cryopreservation"))
```

```{r}
# Subset HVF genes
list_HVF <- VariableFeatures(seurat_obj_final)
seurat_obj_final <- seurat_obj_final[list_HVF, ]

# Extract raw counts and metadata to create SingleCellExperiment object
counts_final <- seurat_obj_final@assays$RNA@counts 
data_final <- seurat_obj_final@assays$RNA@data
metadata_final <- seurat_obj_final@meta.data


# Create single cell experiment object
sce_final <- SingleCellExperiment(assays = list(counts = counts_final,
                                          normcounts = data_final), 
                           colData = metadata_final)
```


# Variance Partition: fitExtractVarPartModel

    Scatter plot with explanatory variables (% variance) 
    
https://www.bioconductor.org/packages/release/bioc/html/variancePartition.html
https://github.com/HelenaLC/simulation-comparison/blob/master/code/05-calc_qc-gene_pve.R 

```{r}
ppFUN <- function(sce) {
    if ("normcounts" %in% assayNames(sce)) {
        logcounts(sce) <- log(normcounts(sce)+1)
    } else sce <- logNormCounts(sce)
    return(sce)
}

qcFUN <- function(sce) {
    i <- c("library_name", "celltypes_1")
    i <- intersect(i, names(colData(sce)))
    if (length(i) == 0) return(NULL)
    y <- logcounts(sce)
    if (!is.matrix(y))
        y <- as.matrix(y)
    y <- y[rowSums(y) != 0, ]    
    f <- as.formula(sprintf("~(1|%s)", i))
    cd <- data.frame(colData(sce)[i])
    pve <- fitExtractVarPartModel(y, f, cd, 
        quiet = TRUE, BPPARAM = SerialParam())
    return(pve[[i]])
}
```

```{r}
sce_final <- ppFUN(sce_final)

pve <- qcFUN(sce_final)
```




# CellMixS
[CellMixS](https://github.com/almutlue/CellMixS), a toolbox to explore group-/batch-specific bias and data integration in single-cell RNA-seq (scRNA-seq) datasets.

It has two major applications:

    * Detection of batch effects and biases in single-cell RNA-seq data.
    * Evaluation and comparison of data integration (e.g. after batch effect correction).

For this purpose it introduces two new metrics:

    * Cellspecific Mixing Score (cms): A test for batch effects within k-nearest neighbouring cells.
    * Local Density Differences (ldfDiff): A score describing the change in relative local cell densities by data integration or projection.
    

## Visualize batch distribution
```{r fig.width=15, fig.height=7}
vis_batch <- visGroup(sce, group = "sample_protocol")
vis_batch_corr <- visGroup(sce_final, group = "sample_protocol")

cowplot::plot_grid(vis_batch, vis_batch_corr, ncol = 2)
```


## Quantify batch effects: Cell-specific mixing scores

```{r}
#You need to specify the batch variable as defined in the colData, 
#the number of k-nearest neighbours to include k and 
# optional the reduced dimensions to use red_dim.

sce <- cms(sce, assay_name = "data", group = "sample_protocol", k=20)
```

```{r fig.width=10, fig.height=7}
# Visualize cell mixing score
visHist(sce)

visMetric(sce, metric_var = "cms_smooth.unaligned")
```

```{r fig.width=10, fig.height=10}
visOverview(sce, 
            "sample_protocol", other_var = "celltype_1")
```

```{r fig.width=10, fig.height=10}

visCluster(sce, metric_var = "cms.unaligned", cluster_var = "celltype_1")
```


## Evaluate data integration
```{r}

```

# PCA

```{r}
# Load FILTERED & Integrated & Annotated
seurat_obj_final <- readRDS(here::here("03_clustering_annotation/results/R_objects/scgtest33_m_LUNG_healthy_cells1_clustering_annotation.rds"))

# Reorder factor
seurat_obj_final$sample_protocol <- factor(x = seurat_obj_final$sample_protocol,
                                    levels = c("Fresh", "Fix&Cut_24h", "Fix&Cut_7d", "Cryopreservation", "Fix&Cut+Cryopreservation"))

# Remove doublets
seurat_obj_final <- seurat_obj_final[, seurat_obj_final$celltypes_1 != "Dobulets APC-B cells"]
```

http://www.sthda.com/english/articles/31-principal-component-methods-in-r-practical-guide/112-pca-principal-component-analysis-essentials/


## PCA by cell profile composition
```{r}
library(ggfortify)
```


```{r}
# Determine the number of cells per cluster per sample
cellprop_profile_df <- seurat_obj_final@meta.data %>% 
  select(c("library_name", "sample_protocol", "celltypes_1")) %>%
  dplyr::count(library_name, sample_protocol, celltypes_1) %>% 
  mutate_if(is.numeric, ~replace(., is.na(.), 0)) # replacing NA by 0

# Compute percentage by condition
cellprop_profile_df <- cellprop_profile_df %>% 
  group_by(sample_protocol) %>%
  mutate(pct_celltypes_1 = n / sum(n)*100)
```

```{r}
immune_profile <- cellprop_profile_df[c("sample_protocol",  "celltypes_1", "pct_celltypes_1")] %>% 
  spread(celltypes_1, pct_celltypes_1)

immune_profile_df <- immune_profile %>% 
  column_to_rownames(., var = "sample_protocol")

immune_profile_df[is.na(immune_profile_df)] <- 0

info <- cellprop_profile_df[c("library_name", "sample_protocol", "celltypes_1")]
# add full metadata to immune_profile
info <- left_join(immune_profile, info, by = "sample_protocol")
info <- distinct(info, sample_protocol, .keep_all = TRUE)

head(immune_profile_df)
```


```{r fig.width=7, fig.height=5}
pca_res <- prcomp(x = immune_profile_df)

autoplot(pca_res, info, colour = 'sample_protocol', scale = 0, size = 5) + 
 #scale_color_manual(values = color_palette)  +
 ggrepel::geom_text_repel(aes(x = pca_res$x[, "PC1"],
                                       y = pca_res$x[, "PC2"],
                                       label = info$sample_protocol), size = 3) +
  theme_light()
```



```{r fig.width=7, fig.height=5}
library("factoextra")

# Percentage of variances explained by each principal component.
fviz_eig(pca_res, ncp=16)

fviz_cos2(pca_res, choice = "var", axes = 1:2)
```


```{r fig.width=7, fig.height=5}
# Graph of individuals
fviz_pca_ind(pca_res,
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )

# Graph of variables
fviz_pca_var(pca_res,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )

# Biplot of individfuals and variables
fviz_pca_biplot(pca_res, repel = TRUE,
                col.var = "#2E9FDF", # Variables color
                col.ind = "#696969"  # Individuals color
                )

# Access to PCA results
# Coordinates -- $coord 
# Contributions to the PCs -- $contrib
# Quality of representation -- $cos2

# Eigenvalues
pca_res_eigenvalue <- get_eigenvalue(pca_res)
# Results for variables
pca_res_variables <- get_pca_var(pca_res)
# Results for individuals
pca_res_individuals <- get_pca_ind(pca_res)


groups <- as.factor(decathlon2$Competition[1:23])
fviz_pca_ind(pca_res,
             col.ind = info$sample_protocol, # color by groups
             palette = c("red",  "blue", "green", "orange", "yellow"),
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
             legend.title = "Groups",
             repel = TRUE
             )
```

```{r}
# PCA results for variables

# Helper function 
#::::::::::::::::::::::::::::::::::::::::
var_coord_func <- function(loadings, comp.sdev){
  loadings*comp.sdev
}
# Compute Coordinates
#::::::::::::::::::::::::::::::::::::::::
loadings <- pca_res$rotation
sdev <- pca_res$sdev
var.coord <- t(apply(loadings, 1, var_coord_func, sdev)) 

# Compute Cos2
#::::::::::::::::::::::::::::::::::::::::
var.cos2 <- var.coord^2

# Compute contributions
#::::::::::::::::::::::::::::::::::::::::
comp.cos2 <- apply(var.cos2, 2, sum)
contrib <- function(var.cos2, comp.cos2){var.cos2*100/comp.cos2}
var.contrib <- t(apply(var.cos2,1, contrib, comp.cos2))
head(var.contrib)
```


```{r}
ggplot(var.contrib, aes(x=PC1, y=PC2)) +
  geom_point() +
  geom_text(aes(label = rownames(var.contrib)))

ggplot(var.contrib, aes(x=PC3, y=PC4)) +
  geom_point() +
  geom_text(aes(label = rownames(var.contrib)))


# Contributions of variables to PC1
fviz_contrib(pca_res, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca_res, choice = "var", axes = 2, top = 10)
# Total contribution on PC1 and PC2
fviz_contrib(pca_res, choice = "ind", axes = 1:2)
```


```{r fig.height=10, fig.width=10}
library("corrplot")
corrplot(var.contrib, is.corr=FALSE)    
```



```{r}
pca_contribs_indv <- as.data.frame(pca_res_individuals$contrib)
pca_contribs_indv$index <- rownames(pca_contribs_indv)

# Merge with metadata information
pca_contribs_indv_full <- cbind(pca_contribs_indv, info)

# Change order
pca_contribs_indv_full <- pca_contribs_indv_full[c(1,2,11,12, 3,4,5,6, 13,14,15,16, 7,8,9,10),]
```


```{r fig.height=5, fig.width=25}
dimesions_list <- unlist(lapply(rep(1:5, 1), function(x) paste0("Dim.", x)))

gg_pca_dim_corr <- purrr::map(dimesions_list, function(dim) {
  
  pca_contribs_indv_full %>% 
  ggplot(aes_string(x = dim, y = 1:length(pca_contribs_indv_full$index), color = "sample_protocol", label="sample_protocol")) + 
  geom_point(size = 3) +
  #scale_color_manual(values = color_palette) +
  theme_classic() +
  #geom_abline(intercept = 0, slope = 1, color = "grey") +
  geom_smooth(color = "black") +
  scale_size(guide = "none") +
  ggrepel::geom_text_repel(size = 3) + 
  labs(x=dim, y = "Samples") +
  theme(legend.position = "none",
        axis.title.x = element_text(size=16),
        axis.title.y = element_text(size=16))
})

cowplot::plot_grid(plotlist = gg_pca_dim_corr, ncol = 5)
```

## PCA by pseudobulk gene expression
```{r}
s <- AverageExpression(object = seurat_obj_final, 
                       assays = "RNA",
                       slot = "scale.data",
                       group.by = "sample_protocol",
                       return.seurat = F)

head(s$RNA)

immune_profile_df <- t(s$RNA)
```


```{r fig.width=7, fig.height=5}
pca_res <- prcomp(x = immune_profile_df)

autoplot(pca_res, info, colour = 'sample_protocol', scale = 0, size = 5) + 
 #scale_color_manual(values = color_palette)  +
 ggrepel::geom_text_repel(aes(x = pca_res$x[, "PC1"],
                                       y = pca_res$x[, "PC2"],
                                       label = info$sample_protocol), size = 3) +
  theme_light()
```




```{r fig.width=7, fig.height=5}
library("factoextra")

# Percentage of variances explained by each principal component.
fviz_eig(pca_res, ncp=16)

fviz_cos2(pca_res, choice = "var", axes = 1:2)
```


```{r fig.width=7, fig.height=5}
# Graph of individuals
fviz_pca_ind(pca_res,
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )

# Graph of variables
fviz_pca_var(pca_res,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )

# Biplot of individfuals and variables
fviz_pca_biplot(pca_res, repel = TRUE,
                col.var = "#2E9FDF", # Variables color
                col.ind = "#696969"  # Individuals color
                )

# Access to PCA results
# Coordinates -- $coord 
# Contributions to the PCs -- $contrib
# Quality of representation -- $cos2

# Eigenvalues
pca_res_eigenvalue <- get_eigenvalue(pca_res)
# Results for variables
pca_res_variables <- get_pca_var(pca_res)
# Results for individuals
pca_res_individuals <- get_pca_ind(pca_res)


groups <- as.factor(decathlon2$Competition[1:23])
fviz_pca_ind(pca_res,
             col.ind = info$sample_protocol, # color by groups
             palette = c("red",  "blue", "green", "orange", "yellow"),
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
             legend.title = "Groups",
             repel = TRUE
             )
```

```{r}
# PCA results for variables

# Helper function 
#::::::::::::::::::::::::::::::::::::::::
var_coord_func <- function(loadings, comp.sdev){
  loadings*comp.sdev
}
# Compute Coordinates
#::::::::::::::::::::::::::::::::::::::::
loadings <- pca_res$rotation
sdev <- pca_res$sdev
var.coord <- t(apply(loadings, 1, var_coord_func, sdev)) 

# Compute Cos2
#::::::::::::::::::::::::::::::::::::::::
var.cos2 <- var.coord^2

# Compute contributions
#::::::::::::::::::::::::::::::::::::::::
comp.cos2 <- apply(var.cos2, 2, sum)
contrib <- function(var.cos2, comp.cos2){var.cos2*100/comp.cos2}
var.contrib <- t(apply(var.cos2,1, contrib, comp.cos2))
head(var.contrib)
```


```{r}
ggplot(var.contrib, aes(x=PC1, y=PC2)) +
  geom_point() +
  geom_text(aes(label = rownames(var.contrib)))

ggplot(var.contrib, aes(x=PC3, y=PC4)) +
  geom_point() +
  geom_text(aes(label = rownames(var.contrib)))


# Contributions of variables to PC1
fviz_contrib(pca_res, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca_res, choice = "var", axes = 2, top = 10)
# Total contribution on PC1 and PC2
fviz_contrib(pca_res, choice = "ind", axes = 1:2)
```


```{r}
pca_contribs_indv <- as.data.frame(pca_res_individuals$contrib)
pca_contribs_indv$index <- rownames(pca_contribs_indv)

# Merge with metadata information
pca_contribs_indv_full <- cbind(pca_contribs_indv, info)

# Change order
pca_contribs_indv_full <- pca_contribs_indv_full[c(1,2,11,12, 3,4,5,6, 13,14,15,16, 7,8,9,10),]
```


```{r fig.height=5, fig.width=25}
dimesions_list <- unlist(lapply(rep(1:5, 1), function(x) paste0("Dim.", x)))

gg_pca_dim_corr <- purrr::map(dimesions_list, function(dim) {
  
  pca_contribs_indv_full %>% 
  ggplot(aes_string(x = dim, y = 1:length(pca_contribs_indv_full$index), color = "sample_protocol", label="sample_protocol")) + 
  geom_point(size = 3) +
  #scale_color_manual(values = color_palette) +
  theme_classic() +
  #geom_abline(intercept = 0, slope = 1, color = "grey") +
  geom_smooth(color = "black") +
  scale_size(guide = "none") +
  ggrepel::geom_text_repel(size = 3) + 
  labs(x=dim, y = "Samples") +
  theme(legend.position = "none",
        axis.title.x = element_text(size=16),
        axis.title.y = element_text(size=16))
})

cowplot::plot_grid(plotlist = gg_pca_dim_corr, ncol = 5)
```

### d
```{r fig.width=15, fig.height=5}
gg_pca_by_library <- DimPlot(
  seurat_obj_final,
  reduction = "pca",
  group.by = "sample_protocol") +
  labs(title = "", color = "Library")

gg_pca_by_sample <- DimPlot(
  seurat_obj_final,
  reduction = "pca",
  group.by = "celltypes_1") +
  labs(title = "", color = "Sample")

gg_pca_by_library + gg_pca_by_sample
```


```{r fig.width=25, fig.height=5}
DimPlot(
  seurat_obj_final,
  reduction = "pca",
  group.by = "celltypes_1",
  split.by = "sample_protocol",
  raster = FALSE) +
  labs(title = "", color = "Sample", shape = "Protocol")
```

```{r}
mat <- Seurat::GetAssayData(seurat_obj_final, assay = "RNA", slot = "scale.data")
pca <- seurat_obj_final[["pca"]]

# Get the total variance:
total_variance <- sum(matrixStats::rowVars(mat))

eigValues = (pca@stdev)^2  ## EigenValues
varExplained = round(eigValues / total_variance * 100, digits = 2)

print(varExplained)
```


## PCA by pseudobulk gene expression by cell-type
```{r}
s <- AverageExpression(object = seurat_obj_final, 
                       assays = "RNA",
                       slot = "data",
                       group.by = c("sample_protocol", "celltypes_1"),
                       return.seurat = F)
head(s$RNA)
```



```{r}

```


# Session Info
```{r}
sessionInfo()
```